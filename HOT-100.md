---
created: 2025-09-03T15:46:32 (UTC +08:00)
tags: []
source: https://leetcode.cn/problem-list/2cktkvj/
author: 
---
```python
from leezy.assists import TreeNode, ListNode
t = TreeNode.make_tree([1, 2, 3, 4, 5, None, 6])
l = ListNode.make_linked_list([1, 2, 3, 4, 5])
```
### 一、链表（共11题）
- [x] [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)
```python
from leezy.assists import ListNode  
from typing import Optional  
  
class Solution:  
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:  
        dummy = ListNode()  
        cur = dummy  
        carry = 0  
        while l1 or l2:  
            x = l1.val if l1 else 0  
            y = l2.val if l2 else 0  
            s = x + y + carry  
            carry = s // 10  
            cur.next = ListNode(s % 10)  
            cur = cur.next  
            if l1:  
                l1 = l1.next  
            if l2:  
                l2 = l2.next   
        if carry:  
            cur.next = ListNode(carry)  
        return dummy.next  
          
# leetcode submit region end(Prohibit modification and deletion)  
l1 = [2,4,3,5]  
l2 = [5,6,4]  
  
L1 = ListNode.make_linked_list(l1)  
L2 = ListNode.make_linked_list(l2)  
  
s = Solution()  
print(s.addTwoNumbers(L1, L2))
```
- [x] [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
```python
class Solution:  
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:  
        dummy = ListNode.make_linked_list([0])  
        dummy.next = head  
        # dummy = ListNode(0, head)  
        first = head  
        second = dummy  
        for i in range(n):  
            first = first.next  
  
        while first:  
            first = first.next  
            second = second.next  

        second.next = second.next.next  
        return dummy.next
```
- [x] [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/?favorite=2cktkvj)
```python
class Solution:  
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:  
        dummy = ListNode.make_linked_list([0])  
        # dummy = ListNode(0)  
        p = dummy  
        p1 = list1  
        p2 = list2  
        while p1 and p2:  
            if p1.val <= p2.val:  
                p.next = p1  
                p1 = p1.next  
            else:  
                p.next = p2  
                p2 = p2.next  
            p = p.next  
        if p1:  
            p.next = p1  
        if p2:  
            p.next = p2  
        return dummy.next
```
- [x] [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/?favorite=2cktkvj)
```python
class Solution:  
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:  
        if not lists:  
            return None  
        if len(lists) == 1:  
            return lists[0]  
        if len(lists) == 2:  
            return self.mergeTwoLists(lists[0], lists[1])  
        mid = len(lists) // 2  
        left = self.mergeKLists(lists[:mid])  
        right = self.mergeKLists(lists[mid:])  
        return self.mergeTwoLists(left, right)  
  
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:  
        dummy = ListNode.make_linked_list([0])  
        # dummy = ListNode(0)
        p = dummy  
        p1 = list1  
        p2 = list2  
        while p1 and p2:  
            if p1.val <= p2.val:  
                p.next = p1  
                p1 = p1.next  
            else:  
                p.next = p2  
                p2 = p2.next  
            p = p.next  
  
        if p1:  
            p.next = p1  
        if p2:  
            p.next = p2  
        return dummy.next
```
- [x] [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/?favorite=2cktkvj)
```python
class Solution:  
    def hasCycle(self, head: Optional[ListNode]) -> bool:  
        slow, fast = head, head  
        while fast and fast.next:  
            slow = slow.next  
            fast = fast.next.next  
            if slow == fast:  
                return True  
        return False
```
- [x] [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/?favorite=2cktkvj)
```python
class Solution:  
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        slow = fast = head  
        while fast and fast.next:  
            slow = slow.next  
            fast = fast.next.next  
            if slow == fast:  
                break  
        else:  
            return None  
        slow = head  
        while slow != fast:  
            slow = slow.next  
            fast = fast.next  
        return slow
```
- [x] [148. 排序链表](https://leetcode.cn/problems/sort-list/description/)  
```python
class Solution:  
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        if not head or not head.next: return head  # termination.  
        # cut the LinkedList at the mid index.        slow, fast = head, head.next  
        while fast and fast.next:  
            fast, slow = fast.next.next, slow.next  
        mid, slow.next = slow.next, None # save and cut.  
        # recursive for cutting.        left, right = self.sortList(head), self.sortList(mid)  
        print('Left: ', left)  
        print('Right: ', right)  
        # merge `left` and `right` linked list and return it.  
        h = res = ListNode(0)  
        while left and right:  
            if left.val < right.val: h.next, left = left, left.next  
            else: h.next, right = right, right.next  
            h = h.next  
        h.next = left if left else right  
        print('Sort: ', res.next)  
        return res.next  
  
    def sortList1(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        if not head:  
            return None  
        nums = []  
        while head:  
            nums.append(head.val)  
            head = head.next  
        nums.sort()  
        head = ListNode(nums[0])  
        p = head  
        for i in range(1, len(nums)):  
            p.next = ListNode(nums[i])  
            p = p.next  
        return head
```
- [x] [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/?favorite=2cktkvj)
```python
from leezy.assists import ListNode  
from typing import Optional  
  
class Solution:  
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:  
        p1, p2 = headA, headB  
        while p1 != p2:  
            p1 = p1.next if p1 else headB  
            p2 = p2.next if p2 else headA  
        return p1  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
listA = [1,9,1]  
listB = [3]  
listO = [2,4]  
La, Lb = ListNode.make_linked_list(listA), ListNode.make_linked_list(listB)  
Lo = ListNode.make_linked_list(listO)  
  
s = Solution()  
  
pa, pb = La, Lb  
while pa and pa.next:  
    pa = pa.next  
else:  
    pa.next = Lo  
  
while pb and pb.next:  
    pb = pb.next  
else:  
    pb.next = Lo  
  
print(La)  
print(Lb)  
  
print(s.getIntersectionNode(La, Lb))
```
- [x] [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
```python
from leezy.assists import ListNode  
from typing import Optional  
class Solution:  
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        cur, pre = head, None  
        while cur:  
            tmp = cur.next  # 暂存后继节点 cur.next            cur.next = pre  # 修改 next 引用指向  
  
            pre = cur  # pre 暂存 cur            cur = tmp  # cur 访问下一节点  
  
            print('cur: ', cur)  
            print('pre: ', pre)  
            print('-'*20)  
        return pre  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
s = Solution()  
print(s.reverseList(ListNode.make_linked_list([1,2,3,4,5])))
```
- [x] [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)  
```python
class Solution:  
    def isPalindrome(self, head: Optional[ListNode]) -> bool:  
        res = []  
        while head:  
            res.append(head.val)  
            head = head.next  
        return res == res[::-1]
```
- [x] [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/?favorite=2cktkvj)
```python
from typing import List  
# leetcode submit region begin(Prohibit modification and deletion)  
class Solution:  
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:  
        people.sort(key=lambda x: (-x[0], x[1]))  
        print('people: ', people)  
        ans = list()  
        for person in people:  
            ans[person[1]:person[1]] = [person]  
            print('ans: ', ans)  
        return ans  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]  
s = Solution()  
print(s.reconstructQueue(people))
```
### 二、二叉树（共14题）
做题心得：
- [x] [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/?favorite=2cktkvj)
```python
from leezy.assists import TreeNode  
from typing import Optional, List  
t = TreeNode.make_tree([1,None,2,3])  
class Solution:  
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:  
        res = []  
        def inorder(root):  
            if not root:  
                return  
            inorder(root.left)  
            res.append(root.val)  
            inorder(root.right)  
        inorder(root)  
        return res  
          
s = Solution()  
print(s.inorderTraversal(t))
```
- [x] [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/?favorite=2cktkvj)  
```python
from leezy.assists import TreeNode  
from typing import Optional, List  
  
class Solution:  
    def isValidBST(self, root: Optional[TreeNode]) -> bool:  
        def valid(node, min_node, max_node):  
            if not node:  
                return True  
            if min_node and node.val <= min_node.val:  
                return False  
            if max_node and node.val >= max_node.val:  
                return False  
            return valid(node.left, min_node, node) and valid(node.right, node, max_node)  
        return valid(root, None, None)  
          
# leetcode submit region end(Prohibit modification and deletion)  
t = TreeNode.make_tree([5,1,4,None,None,3,6])  
s = Solution()  
print(s.isValidBST(t))
```
- [x] [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)
```python
from leezy.assists import TreeNode  
from typing import Optional, List  
class Solution:  
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:  
        def isMirror(left, right):  
            print("left", left)  
            print("right", right)  
            print('-'*20)  
            if not left and not right:  
                return True  
            if not left or not right:  
                return False  
            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)  
        return isMirror(root.left, root.right)  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
  
t = TreeNode.make_tree([1,2,2,3,4,4,3,None,None,5,None,5,5,None,None])  
s = Solution()  
print(s.isSymmetric(t))
```
- [x] [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?favorite=2cktkvj)
```python
from typing import Optional, List  
from leezy.assists import TreeNode  
  
class Solution:  
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:  
        if not root:  
            return []  
        res = []  
  
        def dfs(index, r):  
            if len(res) < index:  
                res.append([])  
            res[index - 1].append(r.val)  
            if r.left:  
                dfs(index + 1, r.left)  
            if r.right:  
                dfs(index + 1, r.right)  
  
        dfs(1, root)  
        return res  
# leetcode submit region end(Prohibit modification and deletion)  
  
s = Solution()  
print(s.levelOrder(TreeNode.make_tree([3,9,20,None,None,15,7])))
```
- [x] [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)  
```python
from leezy.assists import TreeNode  
from typing import Optional  
class Solution:  
    def maxDepth(self, root: Optional[TreeNode]) -> int:  
        if not root:  
            return 0  
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1  

s = Solution()  
print(s.maxDepth(TreeNode.make_tree([3,9,20,None,None,15,7])))
```
- [x] [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)  
```python
from typing import *  
from leezy.assists import TreeNode  
 
class Solution:  
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:  
        if len(inorder) == 0:  
            return None  
        # 前序遍历第一个值为根节点  
        root = TreeNode(preorder[0])  
        # 因为没有重复元素，所以可以直接根据值来查找根节点在中序遍历中的位置  
        mid = inorder.index(preorder[0])  
        # 构建左子树  
        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])  
        # 构建右子树  
        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])  
        return root   
s = Solution()  
print(s.buildTree(preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]))
```
- [x] [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?favorite=2cktkvj)  
```python
from leezy.assists import TreeNode  
from typing import *  
class Solution:  
    def flatten(self, root: Optional[TreeNode]) -> None:  
        def dfs(root:TreeNode):  
            if root is None:  
                return  
            dfs(root.left)  
            dfs(root.right)  
  
            if root.left:  
                p = root.left  
                while p.right:  
                    p = p.right  
                p.right = root.right  
                root.right = root.left  
                root.left = None  

        dfs(root)   
  
s = Solution()  
print(s.flatten(TreeNode.make_tree([1, 2, 5, 3, 4, None, 6])))
```
- [x] [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?favorite=2cktkvj)
```python
class Solution:  
    def maxPathSum(self, root: Optional[TreeNode]) -> int:  
        ans = float('-inf')  
  
        def dfs(root: TreeNode):  
            nonlocal ans  
            if root is None:  
                return 0  
            left = max(0, dfs(root.left))  
            right = max(0, dfs(root.right))  
            ans = max(ans, left + right + root.val)  
            return max(left, right) + root.val  
  
        dfs(root)  
        return ans
```
- [x] [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/?favorite=2cktkvj)
```python
class Solution:  
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:  
        if not root:  
            return None  
        root.left, root.right = root.right, root.left  
        self.invertTree(root.left)  
        self.invertTree(root.right)  
        return root
```
- [x] [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)  
```python
class Solution:  
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':  
        if not root:  
            return None  
        if root == p or root == q:  
            return root  
        left = self.lowestCommonAncestor(root.left, p, q)  
        right = self.lowestCommonAncestor(root.right, p, q)  
        if left and right:  
            return root  
        elif left:  
            return left  
        elif right:  
            return right  
        else:  
            return None
```
[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?favorite=2cktkvj)
[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)  
- [x] [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/)  
```python
class Solution:  
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:  
        self.res = 0  
        def dfs(root):  
            if not root:  
                return 0  
            L = dfs(root.left)  
            R = dfs(root.right)  
            self.res = max(self.res, L + R)  
            return max(L, R) + 1  
        dfs(root)  
        return self.res
```
- [x] [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/?favorite=2cktkvj)
```python
class Solution:  
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:  
        if not root1:  
            return root2  
        if not root2:  
            return root1  
        root1.val += root2.val  
        root1.left = self.mergeTrees(root1.left, root2.left)  
        root1.right = self.mergeTrees(root1.right, root2.right)  
        return root1
```
新版 hot100 题目扩充（以下题目列表不断更新ing~）：
- [x] [LeetCode 108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)
```python
class Solution:  
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:  
        def dfs(left, right):  
            if left > right:  
                return None  
            mid = (left + right) // 2  
            root = TreeNode(nums[mid])  
            root.left = dfs(left, mid - 1)  
            root.right = dfs(mid + 1, right)  
            return root  
        return dfs(0, len(nums) - 1)
```
### 三、DFS/BFS（共6题）
[79. 单词搜索](https://leetcode.cn/problems/word-search/description/)  
```python
class Solution:  
    def exist(self, board: List[List[str]], word: str) -> bool:  
        def dfs(i, j, k):  
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]:  
                return False  
            if k == len(word) - 1:  
                return True  
            tmp = board[i][j]  
            board[i][j] = ''  
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)  
            board[i][j] = tmp  
            return res  

        for i in range(len(board)):  
            for j in range(len(board[0])):  
                if dfs(i, j, 0):  
                    return True  
        return False
s = Solution()  
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]  
word = "ABCCED"
```
[85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/?favorite=2cktkvj) 
[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)
```python
class Solution:  
    def numIslands(self, grid: List[List[str]]) -> int:  
        def dfs(i, j):  
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':  
                return  
            grid[i][j] = '0'  
            print_board(grid)  
            print('-'*30)  
            dfs(i - 1, j)  
            dfs(i + 1, j)  
            dfs(i, j - 1)  
            dfs(i, j + 1)  
  
        res = 0  
        for i in range(len(grid)):  
            for j in range(len(grid[0])):  
                if grid[i][j] == '1':  
                    res += 1  
                    dfs(i, j)  
        return res
```

```
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
------------------------------
0 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
------------------------------
0 1 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 1
------------------------------
0 1 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 1 1
------------------------------
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 1 1
------------------------------
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 1 1
------------------------------
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 1
------------------------------
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
------------------------------
3
```
[207. 课程表](https://leetcode.cn/problems/course-schedule/?favorite=2cktkvj) 
[301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/description/?favorite=2cktkvj) 
```python
class Solution:  
    def removeInvalidParentheses(self, s: str) -> List[str]:  
        def is_valid(s):  
            count = 0  
            for c in s:  
                if c == '(':  
                    count += 1  
                elif c == ')':  
                    count -= 1  
                    if count < 0:  
                        return False  
            return count == 0  
  
        level = {s}  
        while True:  
            valid = list(filter(is_valid, level))  
            if valid:  
                return valid  
  
            next_level = set()  
            for s in level:  
                for i in range(len(s)):  
                    if s[i] in '()':  
                        next_level.add(s[:i] + s[i + 1:])  
            level = next_level
```
[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/solutions/)  
```python
class Solution:  
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:  
        if not root:  
            return 0  
        def dfs(node, target):  
            if not node:  
                return 0  
            res = 0  
            if node.val == target:  
                res += 1  
            res += dfs(node.left, target - node.val)  
            res += dfs(node.right, target - node.val)  
            return res  
        return dfs(root, targetSum) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)
```
### 四、递归/回溯（共6题）
[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
```python
class Solution:  
    def letterCombinations(self, digits: str) -> List[str]:  
        if not digits:  
            return []  
        phoneMap = {  
            "2": "abc",  
            "3": "def",  
            "4": "ghi",  
            "5": "jkl",  
            "6": "mno",  
            "7": "pqrs",  
            "8": "tuv",  
            "9": "wxyz"  
        }  
        res = []  
  
        def dfs(index, path):  
            if index == len(digits):  
                res.append("".join(path))  
                return
            digit = digits[index]  
            letters = phoneMap[digit]  
            for letter in letters:  
                path.append(letter)  
                dfs(index + 1, path)  
                path.pop()  
  
        dfs(0, [])  
        return res
```
[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/description/)  
```python
class Solution:  
    def generateParenthesis(self, n: int) -> List[str]:  
        res = []  
        # 如果左括号数量不大于n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。  
        def dfs(left, right, s):  
            if left == n and right == n:  
                res.append(s)  
                return  
            if left < n:  
                dfs(left + 1, right, s + '(')  
            if right < left:  
                dfs(left, right + 1, s + ')')  
  
        dfs(0, 0, '')  
        return res
```
[39. 组合总和](https://leetcode.cn/problems/combination-sum/description/)  
```python
class Solution:  
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  
        res = []  
  
        def dfs(begin, path, target):  
            if target < 0:  
                return  
            if target == 0:  
                res.append(path[:])  
                return  
            for index in range(begin, len(candidates)):  
                path.append(candidates[index])  
                dfs(index, path, target - candidates[index])  
                path.pop()  
  
        dfs(0, [], target)  
        return res
```
[46. 全排列](https://leetcode.cn/problems/permutations/?favorite=2cktkvj)  
```python
class Solution:  
    def permute(self, nums: List[int]) -> List[List[int]]:  
        res = []  
  
        def dfs(x):  
            if x == len(nums) - 1:  
                res.append(list(nums))  
                return  
            for i in range(x, len(nums)):  
                # 动态维护数组  
                nums[x], nums[i] = nums[i], nums[x]  
                # 继续递归填下一个数  
                dfs(x + 1)  
                # 撤销操作  
                nums[x], nums[i] = nums[i], nums[x]  
  
        dfs(0)  
        return res
```
[78. 子集](https://leetcode.cn/problems/subsets/description/)  
```python
class Solution:  
    def subsets(self, nums: List[int]) -> List[List[int]]:  
        res = []  
        n = len(nums)  
        path = []  
  
        def dfs(i):  
            print(i, path)  
            if i == n:  
                res.append(path.copy())  
                return  
  
            # 不要  
            dfs(i + 1)  
  
            # 要  
            path.append(nums[i])  
            dfs(i + 1)  
  
            path.pop()  
  
        dfs(0)  
        return res
```
[399. 除法求值](https://leetcode.cn/problems/evaluate-division/description/?favorite=2cktkvj) 
### 五、Hash表/map（共3题）
[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)
```python
class Solution:  
    def twoSum(self, nums: List[int], target: int) -> List[int]:  
        for i in range(len(nums)):  
            res = target-nums[i]  
            if res in nums[i+1:]:  
                return [i, nums[i+1:].index(res)+i+1]
```
[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)
```python
class Solution:  
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:  
        hashmap = {}  
        for i, s in enumerate(strs):  
            key = ''.join(sorted(s))  
            if key in hashmap:  
                hashmap[key].append(s)  
            else:  
                hashmap[key] = [s]  
  
        return [hashmap[key] for key in hashmap.keys()]
```
[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?favorite=2cktkvj)
```python
class Solution:  
    def longestConsecutive(self, nums: List[int]) -> int:  
        if not nums:  
            return 0  
        nums.sort()  
  
        hashmap = {}  
        for i, num in enumerate(nums):  
            if num - 1 in hashmap:  
                hashmap[num] = hashmap[num - 1] + 1  
            else:  
                hashmap[num] = 1  
  
        return max(hashmap.values())
```
### 六、位运算（共3题）
[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/description/)
```python
class Solution:  
    def singleNumber(self, nums: List[int]) -> int:  
        dic = {}  
        for num in nums:  
            if num not in dic:  
                dic[num] = 1  
            else:  
                dic[num] += 1  
        res = [k for k, v in dic.items() if v == 1]  
        return res[0]
```
[338. 比特位计数](https://leetcode.cn/problems/counting-bits/description/)
```python
class Solution:  
    def countBits(self, n: int) -> List[int]:  
        res = [0] * (n + 1)  
        for i in range(1, n + 1):  
            res[i] = res[i >> 1] + (i & 1)  
        return res
```
[461. 汉明距离](https://leetcode.cn/problems/hamming-distance/description/)
```python
class Solution:  
    def hammingDistance(self, x: int, y: int) -> int:  
        return bin(x ^ y).count('1')
```
### 七、数组（共5题）
[15. 三数之和](https://leetcode.cn/problems/3sum/description/?favorite=2cktkvj) 
```python
class Solution:  
    def threeSum(self, nums: List[int]) -> List[List[int]]:  
        nums.sort()  
        print(nums)  
        res = []  
  
        for i in range(len(nums) - 2):  
            if i - 1 >= 0 and nums[i] == nums[i - 1]:  
                continue  
            left, right = i + 1, len(nums) - 1  
            while left < right:  
                if nums[left] + nums[right] + nums[i] == 0:  
                    res.append([nums[i], nums[left], nums[right]])  
                    while left < right and nums[left] == nums[left + 1]:  
                        left += 1  
                    while left < right and nums[right] == nums[right - 1]:  
                        right -= 1  
                    left += 1  
                    right -= 1  
                elif nums[left] + nums[right] + nums[i] < 0:  
                    left += 1  
                else:  
                    right -= 1  
        return res
```
[31. 下一个排列](https://leetcode.cn/problems/next-permutation/description/)  

[169. 多数元素](https://leetcode.cn/problems/majority-element/description/)
```python
class Solution:  
    def majorityElement(self, nums: List[int]) -> int:  
        dic = {}  
        for num in nums:  
            if num not in dic:  
                dic[num] = 1  
            else:  
                dic[num] += 1  
        for k, v in dic.items():  
            if v > len(nums) // 2:  
                return k
```
[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/)  
```python
class Solution:  
    def productExceptSelf(self, nums: List[int]) -> List[int]:  
        n = len(nums)  
        res = [1] * n  
        for i in range(1, n):  
            res[i] = res[i - 1] * nums[i - 1]  
        right = 1  
        for i in range(n - 1, -1, -1):  
            res[i] *= right  
            right *= nums[i]  
        return res
```
[448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/)  
```python
#由于 nums 的数字范围均在 [1,n] 中，我们可以利用这一范围**之外**的数字，来表达「是否存在」的含义。
#具体来说，遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 [1,n] 中，增加以后，这些数必然大于 n。最后我们遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。
class Solution:  
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:  
        n = len(nums)  
        for num in nums:  
            x = (num - 1) % n  
            print(x)  
            nums[x] += n  
            print(nums)  
            print('-'*30)  
        ret = [i + 1 for i, num in enumerate(nums) if num <= n]  
        return ret
```
八、二分查找（共5题）
[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/) 
```python
class Solution:  
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:  
        nums = nums1 + nums2  
        nums.sort()  
        n = len(nums)  
        if n % 2 == 0:  
            return (nums[n // 2 - 1] + nums[n // 2]) / 2  
        else:  
            return nums[n // 2]
```
[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)  
```python
class Solution:  
    def search(self, nums: List[int], target: int) -> int:  
        left, right = 0, len(nums) - 1  
        while left <= right:  
            mid = (left + right) // 2  
            if nums[mid] == target:  
                return mid  
            if nums[0] <= nums[mid]:  
                if nums[0] <= target < nums[mid]:  
                    right = mid - 1  
                else:  
                    left = mid + 1  
            else:  
                if nums[mid] < target <= nums[len(nums) - 1]:  
                    left = mid + 1  
                else:  
                    right = mid - 1  
        return -1
```
[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)  
```python
class Solution:  
    def searchRange(self, nums: List[int], target: int) -> List[int]:  
        if target not in nums:  
            return [-1, -1]  
        else:  
            return [nums.index(target), len(nums) - 1 - nums[::-1].index(target)]
```
[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?favorite=2cktkvj)
```python
class Solution:  
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:  
        m, n = len(matrix), len(matrix[0])  
        x, y = 0, n - 1  
        while x < m and y >= 0:  
            print(matrix[x][y])  
            if matrix[x][y] == target:  
                return True  
            elif matrix[x][y] > target:  
                y -= 1  
            else:  
                x += 1  
  
        return False
```
[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)  
新版 hot100 题目扩充（以下题目列表不断更新ing~）：
[LeetCode 35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)
九、双指针/三指针（共3题）
[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)
[75. 颜色分类](https://leetcode.cn/problems/sort-colors/description/) 
[283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)  
十、栈/单调栈（共6题）
[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/?favorite=2cktkvj) 
[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/?favorite=2cktkvj) 
[155. 最小栈](https://leetcode.cn/problems/min-stack/description/)
[394. 字符串解码](https://leetcode.cn/problems/decode-string/description/)  
[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)  
十一、排序（共4题）
[56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/?favorite=2cktkvj)  
[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)  
[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)  
[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/?favorite=2cktkvj)
十二、前缀和（共1题）
[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
十三、字典树/前缀树（共1题）
[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/))  
十四、LRU缓存（共1题）
[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/?favorite=2cktkvj)  
十五、动态规划（共23题）
[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/description/?favorite=2cktkvj)
[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?favorite=2cktkvj)
[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)
[62. 不同路径](https://leetcode.cn/problems/unique-paths/description/)
[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/?favorite=2cktkvj)
[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)
[72. 编辑距离](https://leetcode.cn/problems/edit-distance/?favorite=2cktkvj)
[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)
[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)
[139. 单词拆分](https://leetcode.cn/problems/word-break/?favorite=2cktkvj)  
[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/?favorite=2cktkvj)
[198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)
[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/description/?favorite=2cktkvj)
[221. 最大正方形](https://leetcode.cn/problems/maximal-square/description/)
[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/)  
[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)  
[309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/?favorite=2cktkvj)  
[312. 戳气球](https://leetcode.cn/problems/burst-balloons/?favorite=2cktkvj)
[322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/)  
[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/?favorite=2cktkvj)
[494. 目标和](https://leetcode.cn/problems/target-sum/description/)  
[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/description/?favorite=2cktkvj)  
[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)
十六、滑动窗口（共4题）
[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)  
[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/?favorite=2cktkvj)
[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/?favorite=2cktkvj)
[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?favorite=2cktkvj)  
十七、贪心（共1题）
[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
十八、数学（共1题）
[48. 旋转图像](https://leetcode.cn/problems/rotate-image/solutions/?favorite=2cktkvj)  
十九、其它（共1题）
[621. 任务调度器](https://leetcode.cn/problems/task-scheduler/solutions/?favorite=2cktkvj)