---
created: 2025-09-03T15:46:32 (UTC +08:00)
tags: []
source: https://leetcode.cn/problem-list/2cktkvj/
author: 
---
```python
from leezy.assists import TreeNode, ListNode
t = TreeNode.make_tree([1, 2, 3, 4, 5, None, 6])
l = ListNode.make_linked_list([1, 2, 3, 4, 5])
```
一、链表（共11题）
- [x] [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/)
```python
from leezy.assists import ListNode  
from typing import Optional  
  
class Solution:  
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:  
        dummy = ListNode()  
        cur = dummy  
        carry = 0  
        while l1 or l2:  
            x = l1.val if l1 else 0  
            y = l2.val if l2 else 0  
            s = x + y + carry  
            carry = s // 10  
            cur.next = ListNode(s % 10)  
            cur = cur.next  
            if l1:  
                l1 = l1.next  
            if l2:  
                l2 = l2.next   
        if carry:  
            cur.next = ListNode(carry)  
        return dummy.next  
          
# leetcode submit region end(Prohibit modification and deletion)  
l1 = [2,4,3,5]  
l2 = [5,6,4]  
  
L1 = ListNode.make_linked_list(l1)  
L2 = ListNode.make_linked_list(l2)  
  
s = Solution()  
print(s.addTwoNumbers(L1, L2))
```
- [x] [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
```python
class Solution:  
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:  
        dummy = ListNode.make_linked_list([0])  
        dummy.next = head  
        # dummy = ListNode(0, head)  
        first = head  
        second = dummy  
        for i in range(n):  
            first = first.next  
  
        while first:  
            first = first.next  
            second = second.next  

        second.next = second.next.next  
        return dummy.next
```
- [x] [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/?favorite=2cktkvj)
```python
class Solution:  
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:  
        dummy = ListNode.make_linked_list([0])  
        # dummy = ListNode(0)  
        p = dummy  
        p1 = list1  
        p2 = list2  
        while p1 and p2:  
            if p1.val <= p2.val:  
                p.next = p1  
                p1 = p1.next  
            else:  
                p.next = p2  
                p2 = p2.next  
            p = p.next  
        if p1:  
            p.next = p1  
        if p2:  
            p.next = p2  
        return dummy.next
```
- [x] [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/?favorite=2cktkvj)
```python
class Solution:  
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:  
        if not lists:  
            return None  
        if len(lists) == 1:  
            return lists[0]  
        if len(lists) == 2:  
            return self.mergeTwoLists(lists[0], lists[1])  
        mid = len(lists) // 2  
        left = self.mergeKLists(lists[:mid])  
        right = self.mergeKLists(lists[mid:])  
        return self.mergeTwoLists(left, right)  
  
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:  
        dummy = ListNode.make_linked_list([0])  
        # dummy = ListNode(0)
        p = dummy  
        p1 = list1  
        p2 = list2  
        while p1 and p2:  
            if p1.val <= p2.val:  
                p.next = p1  
                p1 = p1.next  
            else:  
                p.next = p2  
                p2 = p2.next  
            p = p.next  
  
        if p1:  
            p.next = p1  
        if p2:  
            p.next = p2  
        return dummy.next
```
- [x] [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/?favorite=2cktkvj)
```python
class Solution:  
    def hasCycle(self, head: Optional[ListNode]) -> bool:  
        slow, fast = head, head  
        while fast and fast.next:  
            slow = slow.next  
            fast = fast.next.next  
            if slow == fast:  
                return True  
        return False
```
- [x] [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/?favorite=2cktkvj)
```python
class Solution:  
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        slow = fast = head  
        while fast and fast.next:  
            slow = slow.next  
            fast = fast.next.next  
            if slow == fast:  
                break  
        else:  
            return None  
        slow = head  
        while slow != fast:  
            slow = slow.next  
            fast = fast.next  
        return slow
```
- [x] [148. 排序链表](https://leetcode.cn/problems/sort-list/description/)  
```python
class Solution:  
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        if not head or not head.next: return head  # termination.  
        # cut the LinkedList at the mid index.        slow, fast = head, head.next  
        while fast and fast.next:  
            fast, slow = fast.next.next, slow.next  
        mid, slow.next = slow.next, None # save and cut.  
        # recursive for cutting.        left, right = self.sortList(head), self.sortList(mid)  
        print('Left: ', left)  
        print('Right: ', right)  
        # merge `left` and `right` linked list and return it.  
        h = res = ListNode(0)  
        while left and right:  
            if left.val < right.val: h.next, left = left, left.next  
            else: h.next, right = right, right.next  
            h = h.next  
        h.next = left if left else right  
        print('Sort: ', res.next)  
        return res.next  
  
    def sortList1(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        if not head:  
            return None  
        nums = []  
        while head:  
            nums.append(head.val)  
            head = head.next  
        nums.sort()  
        head = ListNode(nums[0])  
        p = head  
        for i in range(1, len(nums)):  
            p.next = ListNode(nums[i])  
            p = p.next  
        return head
```
- [x] [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/?favorite=2cktkvj)
```python
from leezy.assists import ListNode  
from typing import Optional  
  
class Solution:  
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:  
        p1, p2 = headA, headB  
        while p1 != p2:  
            p1 = p1.next if p1 else headB  
            p2 = p2.next if p2 else headA  
        return p1  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
listA = [1,9,1]  
listB = [3]  
listO = [2,4]  
La, Lb = ListNode.make_linked_list(listA), ListNode.make_linked_list(listB)  
Lo = ListNode.make_linked_list(listO)  
  
s = Solution()  
  
pa, pb = La, Lb  
while pa and pa.next:  
    pa = pa.next  
else:  
    pa.next = Lo  
  
while pb and pb.next:  
    pb = pb.next  
else:  
    pb.next = Lo  
  
print(La)  
print(Lb)  
  
print(s.getIntersectionNode(La, Lb))
```
[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
```python
from leezy.assists import ListNode  
from typing import Optional  
class Solution:  
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:  
        cur, pre = head, None  
        while cur:  
            tmp = cur.next  # 暂存后继节点 cur.next            cur.next = pre  # 修改 next 引用指向  
  
            pre = cur  # pre 暂存 cur            cur = tmp  # cur 访问下一节点  
  
            print('cur: ', cur)  
            print('pre: ', pre)  
            print('-'*20)  
        return pre  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
s = Solution()  
print(s.reverseList(ListNode.make_linked_list([1,2,3,4,5])))
```
[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)  
```python
class Solution:  
    def isPalindrome(self, head: Optional[ListNode]) -> bool:  
        res = []  
        while head:  
            res.append(head.val)  
            head = head.next  
        return res == res[::-1]
```
[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/?favorite=2cktkvj)
```python
from typing import List  
# leetcode submit region begin(Prohibit modification and deletion)  
class Solution:  
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:  
        people.sort(key=lambda x: (-x[0], x[1]))  
        print('people: ', people)  
        ans = list()  
        for person in people:  
            ans[person[1]:person[1]] = [person]  
            print('ans: ', ans)  
        return ans  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]  
s = Solution()  
print(s.reconstructQueue(people))
```
二、二叉树（共14题）
做题心得：
[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/?favorite=2cktkvj)
```python
from leezy.assists import TreeNode  
from typing import Optional, List  
t = TreeNode.make_tree([1,None,2,3])  
class Solution:  
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:  
        res = []  
        def inorder(root):  
            if not root:  
                return  
            inorder(root.left)  
            res.append(root.val)  
            inorder(root.right)  
        inorder(root)  
        return res  
          
s = Solution()  
print(s.inorderTraversal(t))
```
[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/?favorite=2cktkvj)  
```python
from leezy.assists import TreeNode  
from typing import Optional, List  
  
class Solution:  
    def isValidBST(self, root: Optional[TreeNode]) -> bool:  
        def valid(node, min_node, max_node):  
            if not node:  
                return True  
            if min_node and node.val <= min_node.val:  
                return False  
            if max_node and node.val >= max_node.val:  
                return False  
            return valid(node.left, min_node, node) and valid(node.right, node, max_node)  
        return valid(root, None, None)  
          
# leetcode submit region end(Prohibit modification and deletion)  
t = TreeNode.make_tree([5,1,4,None,None,3,6])  
s = Solution()  
print(s.isValidBST(t))
```
[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)
```python
from leezy.assists import TreeNode  
from typing import Optional, List  
class Solution:  
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:  
        def isMirror(left, right):  
            print("left", left)  
            print("right", right)  
            print('-'*20)  
            if not left and not right:  
                return True  
            if not left or not right:  
                return False  
            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)  
        return isMirror(root.left, root.right)  
          
# leetcode submit region end(Prohibit modification and deletion)  
  
  
t = TreeNode.make_tree([1,2,2,3,4,4,3,None,None,5,None,5,5,None,None])  
s = Solution()  
print(s.isSymmetric(t))
```
[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?favorite=2cktkvj)
[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)  
[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)  
[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?favorite=2cktkvj)  
[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?favorite=2cktkvj)
[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/?favorite=2cktkvj)
[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)  
[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?favorite=2cktkvj)
[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)  
[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/)  
[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/?favorite=2cktkvj)
新版 hot100 题目扩充（以下题目列表不断更新ing~）：
[LeetCode 108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)
三、DFS/BFS（共6题）
[79. 单词搜索](https://leetcode.cn/problems/word-search/description/)  
[85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/?favorite=2cktkvj) 
[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)
[207. 课程表](https://leetcode.cn/problems/course-schedule/?favorite=2cktkvj) 
[301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/description/?favorite=2cktkvj) 
[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/solutions/)  
四、递归/回溯（共6题）
[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/description/)  
[39. 组合总和](https://leetcode.cn/problems/combination-sum/description/)  
[46. 全排列](https://leetcode.cn/problems/permutations/?favorite=2cktkvj)  
[78. 子集](https://leetcode.cn/problems/subsets/description/)  
[399. 除法求值](https://leetcode.cn/problems/evaluate-division/description/?favorite=2cktkvj) 
五、Hash表/map（共3题）
[1. 两数之和](https://leetcode.cn/problems/two-sum/description/)
[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)
[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?favorite=2cktkvj)
六、位运算（共3题）
[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/description/)
[338. 比特位计数](https://leetcode.cn/problems/counting-bits/description/)
[461. 汉明距离](https://leetcode.cn/problems/hamming-distance/description/)
七、数组（共5题）
[15. 三数之和](https://leetcode.cn/problems/3sum/description/?favorite=2cktkvj) 待研究
[31. 下一个排列](https://leetcode.cn/problems/next-permutation/description/)  
[169. 多数元素](https://leetcode.cn/problems/majority-element/description/)
[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/)  
[448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/)  
八、二分查找（共5题）
[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/) 
[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)  
[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)  
[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?favorite=2cktkvj)
[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)  
新版 hot100 题目扩充（以下题目列表不断更新ing~）：
[LeetCode 35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)
九、双指针/三指针（共3题）
[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)
[75. 颜色分类](https://leetcode.cn/problems/sort-colors/description/) 
[283. 移动零](https://leetcode.cn/problems/move-zeroes/description/)  
十、栈/单调栈（共6题）
[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/?favorite=2cktkvj) 
[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/?favorite=2cktkvj) 
[155. 最小栈](https://leetcode.cn/problems/min-stack/description/)
[394. 字符串解码](https://leetcode.cn/problems/decode-string/description/)  
[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)  
十一、排序（共4题）
[56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/?favorite=2cktkvj)  
[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)  
[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)  
[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/?favorite=2cktkvj)
十二、前缀和（共1题）
[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
十三、字典树/前缀树（共1题）
[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/))  
十四、LRU缓存（共1题）
[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/?favorite=2cktkvj)  
十五、动态规划（共23题）
[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/description/?favorite=2cktkvj)
[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?favorite=2cktkvj)
[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)
[62. 不同路径](https://leetcode.cn/problems/unique-paths/description/)
[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/?favorite=2cktkvj)
[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)
[72. 编辑距离](https://leetcode.cn/problems/edit-distance/?favorite=2cktkvj)
[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)
[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)
[139. 单词拆分](https://leetcode.cn/problems/word-break/?favorite=2cktkvj)  
[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/?favorite=2cktkvj)
[198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)
[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/description/?favorite=2cktkvj)
[221. 最大正方形](https://leetcode.cn/problems/maximal-square/description/)
[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/)  
[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/)  
[309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/?favorite=2cktkvj)  
[312. 戳气球](https://leetcode.cn/problems/burst-balloons/?favorite=2cktkvj)
[322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/)  
[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/?favorite=2cktkvj)
[494. 目标和](https://leetcode.cn/problems/target-sum/description/)  
[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/description/?favorite=2cktkvj)  
[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)
十六、滑动窗口（共4题）
[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)  
[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/?favorite=2cktkvj)
[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/?favorite=2cktkvj)
[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?favorite=2cktkvj)  
十七、贪心（共1题）
[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
十八、数学（共1题）
[48. 旋转图像](https://leetcode.cn/problems/rotate-image/solutions/?favorite=2cktkvj)  
十九、其它（共1题）
[621. 任务调度器](https://leetcode.cn/problems/task-scheduler/solutions/?favorite=2cktkvj)